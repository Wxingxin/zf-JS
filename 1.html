<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    let a = {n: 1}
let b = a
a.x = a = {n: 2}
console.log(a.x)
console.log(b)

// 好的，第三行代码是这一段的核心部分：

// javascript
// 复制
// 编辑
// a.x = a = { n: 2 };
// 这条代码结合了对象属性赋值、变量赋值以及 JavaScript 的表达式计算顺序，导致了复杂的行为。我们一步步拆解分析：
// 1. 关键规则和优先级
// 点运算符 (a.x) 的优先级高于赋值运算符 (=)：

// a.x = ... 是第一个操作，但赋值右侧的整个表达式 a = { n: 2 } 需要先被计算。
// a = { n: 2 } 重新给 a 赋值，并返回新对象 { n: 2 }。
// 赋值表达式的返回值：
// 赋值表达式 a = { n: 2 } 的返回值是新分配的对象 { n: 2 }。
// 引用对象的影响：
// a 和 b 开始时指向同一个对象 { n: 1 }。
// 修改 a 并不直接影响 b，但如果通过 a.x 修改原对象的属性时，b 会感受到变化。
// 2. 拆解 a.x = a = { n: 2 };
// 我们按照执行顺序详细分解：
// Step 1：a = { n: 2 }
// 这是表达式的右侧部分，优先计算。
// a 被重新赋值，指向一个新对象 { n: 2 }。
// 但是，赋值表达式 a = { n: 2 } 的返回值是新对象 { n: 2 }，并不会立即影响 a.x 的操作。
// Step 2：计算 a.x
// 在右侧表达式执行之前，a.x 绑定的仍是最初的 a 对象（即 { n: 1 }）。
// 现在 a.x = ... 的赋值操作会在这个原始对象 { n: 1 } 上添加一个属性 x，其值为右侧表达式的结果，即新对象 { n: 2 }。
  </script>
</body>
</html>